/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type HostnameObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	OwnershipVerification map[string]*string `json:"ownershipVerification,omitempty" tf:"ownership_verification,omitempty"`

	OwnershipVerificationHTTP map[string]*string `json:"ownershipVerificationHttp,omitempty" tf:"ownership_verification_http,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type HostnameParameters struct {

	// +kubebuilder:validation:Optional
	CustomOriginServer *string `json:"customOriginServer,omitempty" tf:"custom_origin_server,omitempty"`

	// +kubebuilder:validation:Optional
	CustomOriginSni *string `json:"customOriginSni,omitempty" tf:"custom_origin_sni,omitempty"`

	// +kubebuilder:validation:Required
	Hostname *string `json:"hostname" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	SSL []SSLParameters `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// +kubebuilder:validation:Required
	ZoneID *string `json:"zoneId" tf:"zone_id,omitempty"`
}

type SSLObservation struct {
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	ValidationErrors []ValidationErrorsObservation `json:"validationErrors,omitempty" tf:"validation_errors,omitempty"`

	ValidationRecords []ValidationRecordsObservation `json:"validationRecords,omitempty" tf:"validation_records,omitempty"`
}

type SSLParameters struct {

	// +kubebuilder:validation:Optional
	CertificateAuthority *string `json:"certificateAuthority,omitempty" tf:"certificate_authority,omitempty"`

	// +kubebuilder:validation:Optional
	CustomCertificate *string `json:"customCertificate,omitempty" tf:"custom_certificate,omitempty"`

	// +kubebuilder:validation:Optional
	CustomKey *string `json:"customKey,omitempty" tf:"custom_key,omitempty"`

	// +kubebuilder:validation:Optional
	Method *string `json:"method,omitempty" tf:"method,omitempty"`

	// +kubebuilder:validation:Optional
	Settings []SettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	Wildcard *bool `json:"wildcard,omitempty" tf:"wildcard,omitempty"`
}

type SettingsObservation struct {
}

type SettingsParameters struct {

	// +kubebuilder:validation:Optional
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// +kubebuilder:validation:Optional
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Optional
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// +kubebuilder:validation:Optional
	Tls13 *string `json:"tls13,omitempty" tf:"tls13,omitempty"`
}

type ValidationErrorsObservation struct {
}

type ValidationErrorsParameters struct {

	// +kubebuilder:validation:Required
	Message *string `json:"message" tf:"message,omitempty"`
}

type ValidationRecordsObservation struct {
}

type ValidationRecordsParameters struct {

	// +kubebuilder:validation:Required
	CnameName *string `json:"cnameName" tf:"cname_name,omitempty"`

	// +kubebuilder:validation:Required
	CnameTarget *string `json:"cnameTarget" tf:"cname_target,omitempty"`

	// +kubebuilder:validation:Required
	Emails []*string `json:"emails" tf:"emails,omitempty"`

	// +kubebuilder:validation:Required
	HTTPBody *string `json:"httpBody" tf:"http_body,omitempty"`

	// +kubebuilder:validation:Required
	HTTPURL *string `json:"httpUrl" tf:"http_url,omitempty"`

	// +kubebuilder:validation:Required
	TxtName *string `json:"txtName" tf:"txt_name,omitempty"`

	// +kubebuilder:validation:Required
	TxtValue *string `json:"txtValue" tf:"txt_value,omitempty"`
}

// HostnameSpec defines the desired state of Hostname
type HostnameSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     HostnameParameters `json:"forProvider"`
}

// HostnameStatus defines the observed state of Hostname.
type HostnameStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        HostnameObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Hostname is the Schema for the Hostnames API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflarejet}
type Hostname struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              HostnameSpec   `json:"spec"`
	Status            HostnameStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// HostnameList contains a list of Hostnames
type HostnameList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Hostname `json:"items"`
}

// Repository type metadata.
var (
	Hostname_Kind             = "Hostname"
	Hostname_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Hostname_Kind}.String()
	Hostname_KindAPIVersion   = Hostname_Kind + "." + CRDGroupVersion.String()
	Hostname_GroupVersionKind = CRDGroupVersion.WithKind(Hostname_Kind)
)

func init() {
	SchemeBuilder.Register(&Hostname{}, &HostnameList{})
}
