/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type InitialSettingsObservation struct {
}

type InitialSettingsParameters struct {

	// +kubebuilder:validation:Required
	AlwaysOnline *string `json:"alwaysOnline" tf:"always_online,omitempty"`

	// +kubebuilder:validation:Required
	AlwaysUseHTTPS *string `json:"alwaysUseHttps" tf:"always_use_https,omitempty"`

	// +kubebuilder:validation:Required
	AutomaticHTTPSRewrites *string `json:"automaticHttpsRewrites" tf:"automatic_https_rewrites,omitempty"`

	// +kubebuilder:validation:Required
	BinaryAst *string `json:"binaryAst" tf:"binary_ast,omitempty"`

	// +kubebuilder:validation:Required
	Brotli *string `json:"brotli" tf:"brotli,omitempty"`

	// +kubebuilder:validation:Required
	BrowserCacheTTL *float64 `json:"browserCacheTtl" tf:"browser_cache_ttl,omitempty"`

	// +kubebuilder:validation:Required
	BrowserCheck *string `json:"browserCheck" tf:"browser_check,omitempty"`

	// +kubebuilder:validation:Required
	CacheLevel *string `json:"cacheLevel" tf:"cache_level,omitempty"`

	// +kubebuilder:validation:Required
	ChallengeTTL *float64 `json:"challengeTtl" tf:"challenge_ttl,omitempty"`

	// +kubebuilder:validation:Required
	Ciphers []*string `json:"ciphers" tf:"ciphers,omitempty"`

	// +kubebuilder:validation:Required
	CnameFlattening *string `json:"cnameFlattening" tf:"cname_flattening,omitempty"`

	// +kubebuilder:validation:Required
	DevelopmentMode *string `json:"developmentMode" tf:"development_mode,omitempty"`

	// +kubebuilder:validation:Required
	EarlyHints *string `json:"earlyHints" tf:"early_hints,omitempty"`

	// +kubebuilder:validation:Required
	EmailObfuscation *string `json:"emailObfuscation" tf:"email_obfuscation,omitempty"`

	// +kubebuilder:validation:Required
	FilterLogsToCloudflare *string `json:"filterLogsToCloudflare" tf:"filter_logs_to_cloudflare,omitempty"`

	// +kubebuilder:validation:Required
	H2Prioritization *string `json:"h2Prioritization" tf:"h2_prioritization,omitempty"`

	// +kubebuilder:validation:Required
	HotlinkProtection *string `json:"hotlinkProtection" tf:"hotlink_protection,omitempty"`

	// +kubebuilder:validation:Required
	Http2 *string `json:"http2" tf:"http2,omitempty"`

	// +kubebuilder:validation:Required
	Http3 *string `json:"http3" tf:"http3,omitempty"`

	// +kubebuilder:validation:Required
	IPGeolocation *string `json:"ipGeolocation" tf:"ip_geolocation,omitempty"`

	// +kubebuilder:validation:Required
	IPv6 *string `json:"ipv6" tf:"ipv6,omitempty"`

	// +kubebuilder:validation:Required
	ImageResizing *string `json:"imageResizing" tf:"image_resizing,omitempty"`

	// +kubebuilder:validation:Required
	LogToCloudflare *string `json:"logToCloudflare" tf:"log_to_cloudflare,omitempty"`

	// +kubebuilder:validation:Required
	MaxUpload *float64 `json:"maxUpload" tf:"max_upload,omitempty"`

	// +kubebuilder:validation:Required
	MinTLSVersion *string `json:"minTlsVersion" tf:"min_tls_version,omitempty"`

	// +kubebuilder:validation:Required
	Minify []MinifyParameters `json:"minify" tf:"minify,omitempty"`

	// +kubebuilder:validation:Required
	Mirage *string `json:"mirage" tf:"mirage,omitempty"`

	// +kubebuilder:validation:Required
	MobileRedirect []MobileRedirectParameters `json:"mobileRedirect" tf:"mobile_redirect,omitempty"`

	// +kubebuilder:validation:Required
	OpportunisticEncryption *string `json:"opportunisticEncryption" tf:"opportunistic_encryption,omitempty"`

	// +kubebuilder:validation:Required
	OpportunisticOnion *string `json:"opportunisticOnion" tf:"opportunistic_onion,omitempty"`

	// +kubebuilder:validation:Required
	OrangeToOrange *string `json:"orangeToOrange" tf:"orange_to_orange,omitempty"`

	// +kubebuilder:validation:Required
	OriginErrorPagePassThru *string `json:"originErrorPagePassThru" tf:"origin_error_page_pass_thru,omitempty"`

	// +kubebuilder:validation:Required
	Polish *string `json:"polish" tf:"polish,omitempty"`

	// +kubebuilder:validation:Required
	PrefetchPreload *string `json:"prefetchPreload" tf:"prefetch_preload,omitempty"`

	// +kubebuilder:validation:Required
	PrivacyPass *string `json:"privacyPass" tf:"privacy_pass,omitempty"`

	// +kubebuilder:validation:Required
	ProxyReadTimeout *string `json:"proxyReadTimeout" tf:"proxy_read_timeout,omitempty"`

	// +kubebuilder:validation:Required
	PseudoIPv4 *string `json:"pseudoIpv4" tf:"pseudo_ipv4,omitempty"`

	// +kubebuilder:validation:Required
	ResponseBuffering *string `json:"responseBuffering" tf:"response_buffering,omitempty"`

	// +kubebuilder:validation:Required
	RocketLoader *string `json:"rocketLoader" tf:"rocket_loader,omitempty"`

	// +kubebuilder:validation:Required
	SSL *string `json:"ssl" tf:"ssl,omitempty"`

	// +kubebuilder:validation:Required
	SecurityHeader []SecurityHeaderParameters `json:"securityHeader" tf:"security_header,omitempty"`

	// +kubebuilder:validation:Required
	SecurityLevel *string `json:"securityLevel" tf:"security_level,omitempty"`

	// +kubebuilder:validation:Required
	ServerSideExclude *string `json:"serverSideExclude" tf:"server_side_exclude,omitempty"`

	// +kubebuilder:validation:Required
	SortQueryStringForCache *string `json:"sortQueryStringForCache" tf:"sort_query_string_for_cache,omitempty"`

	// +kubebuilder:validation:Required
	TLS12Only *string `json:"tls12Only" tf:"tls_1_2_only,omitempty"`

	// +kubebuilder:validation:Required
	TLS13 *string `json:"tls13" tf:"tls_1_3,omitempty"`

	// +kubebuilder:validation:Required
	TLSClientAuth *string `json:"tlsClientAuth" tf:"tls_client_auth,omitempty"`

	// +kubebuilder:validation:Required
	TrueClientIPHeader *string `json:"trueClientIpHeader" tf:"true_client_ip_header,omitempty"`

	// +kubebuilder:validation:Required
	UniversalSSL *string `json:"universalSsl" tf:"universal_ssl,omitempty"`

	// +kubebuilder:validation:Required
	VisitorIP *string `json:"visitorIp" tf:"visitor_ip,omitempty"`

	// +kubebuilder:validation:Required
	Waf *string `json:"waf" tf:"waf,omitempty"`

	// +kubebuilder:validation:Required
	Webp *string `json:"webp" tf:"webp,omitempty"`

	// +kubebuilder:validation:Required
	Websockets *string `json:"websockets" tf:"websockets,omitempty"`

	// +kubebuilder:validation:Required
	ZeroRtt *string `json:"zeroRtt" tf:"zero_rtt,omitempty"`
}

type MinifyObservation struct {
}

type MinifyParameters struct {

	// +kubebuilder:validation:Required
	CSS *string `json:"css" tf:"css,omitempty"`

	// +kubebuilder:validation:Required
	HTML *string `json:"html" tf:"html,omitempty"`

	// +kubebuilder:validation:Required
	Js *string `json:"js" tf:"js,omitempty"`
}

type MobileRedirectObservation struct {
}

type MobileRedirectParameters struct {

	// +kubebuilder:validation:Required
	MobileSubdomain *string `json:"mobileSubdomain" tf:"mobile_subdomain,omitempty"`

	// +kubebuilder:validation:Required
	Status *string `json:"status" tf:"status,omitempty"`

	// +kubebuilder:validation:Required
	StripURI *bool `json:"stripUri" tf:"strip_uri,omitempty"`
}

type SecurityHeaderObservation struct {
}

type SecurityHeaderParameters struct {

	// +kubebuilder:validation:Required
	Enabled *bool `json:"enabled" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	IncludeSubdomains *bool `json:"includeSubdomains" tf:"include_subdomains,omitempty"`

	// +kubebuilder:validation:Required
	MaxAge *float64 `json:"maxAge" tf:"max_age,omitempty"`

	// +kubebuilder:validation:Required
	Nosniff *bool `json:"nosniff" tf:"nosniff,omitempty"`

	// +kubebuilder:validation:Required
	Preload *bool `json:"preload" tf:"preload,omitempty"`
}

type SettingsMinifyObservation struct {
}

type SettingsMinifyParameters struct {

	// +kubebuilder:validation:Required
	CSS *string `json:"css" tf:"css,omitempty"`

	// +kubebuilder:validation:Required
	HTML *string `json:"html" tf:"html,omitempty"`

	// +kubebuilder:validation:Required
	Js *string `json:"js" tf:"js,omitempty"`
}

type SettingsMobileRedirectObservation struct {
}

type SettingsMobileRedirectParameters struct {

	// +kubebuilder:validation:Required
	MobileSubdomain *string `json:"mobileSubdomain" tf:"mobile_subdomain,omitempty"`

	// +kubebuilder:validation:Required
	Status *string `json:"status" tf:"status,omitempty"`

	// +kubebuilder:validation:Required
	StripURI *bool `json:"stripUri" tf:"strip_uri,omitempty"`
}

type SettingsObservation struct {
}

type SettingsOverrideObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InitialSettings []InitialSettingsObservation `json:"initialSettings,omitempty" tf:"initial_settings,omitempty"`

	InitialSettingsReadAt *string `json:"initialSettingsReadAt,omitempty" tf:"initial_settings_read_at,omitempty"`

	ReadonlySettings []*string `json:"readonlySettings,omitempty" tf:"readonly_settings,omitempty"`

	ZoneStatus *string `json:"zoneStatus,omitempty" tf:"zone_status,omitempty"`

	ZoneType *string `json:"zoneType,omitempty" tf:"zone_type,omitempty"`
}

type SettingsOverrideParameters struct {

	// +kubebuilder:validation:Optional
	Settings []SettingsParameters `json:"settings,omitempty" tf:"settings,omitempty"`

	// +kubebuilder:validation:Required
	ZoneID *string `json:"zoneId" tf:"zone_id,omitempty"`
}

type SettingsParameters struct {

	// +kubebuilder:validation:Optional
	AlwaysOnline *string `json:"alwaysOnline,omitempty" tf:"always_online,omitempty"`

	// +kubebuilder:validation:Optional
	AlwaysUseHTTPS *string `json:"alwaysUseHttps,omitempty" tf:"always_use_https,omitempty"`

	// +kubebuilder:validation:Optional
	AutomaticHTTPSRewrites *string `json:"automaticHttpsRewrites,omitempty" tf:"automatic_https_rewrites,omitempty"`

	// +kubebuilder:validation:Optional
	BinaryAst *string `json:"binaryAst,omitempty" tf:"binary_ast,omitempty"`

	// +kubebuilder:validation:Optional
	Brotli *string `json:"brotli,omitempty" tf:"brotli,omitempty"`

	// +kubebuilder:validation:Optional
	BrowserCacheTTL *float64 `json:"browserCacheTtl,omitempty" tf:"browser_cache_ttl,omitempty"`

	// +kubebuilder:validation:Optional
	BrowserCheck *string `json:"browserCheck,omitempty" tf:"browser_check,omitempty"`

	// +kubebuilder:validation:Optional
	CacheLevel *string `json:"cacheLevel,omitempty" tf:"cache_level,omitempty"`

	// +kubebuilder:validation:Optional
	ChallengeTTL *float64 `json:"challengeTtl,omitempty" tf:"challenge_ttl,omitempty"`

	// +kubebuilder:validation:Optional
	Ciphers []*string `json:"ciphers,omitempty" tf:"ciphers,omitempty"`

	// +kubebuilder:validation:Optional
	CnameFlattening *string `json:"cnameFlattening,omitempty" tf:"cname_flattening,omitempty"`

	// +kubebuilder:validation:Optional
	DevelopmentMode *string `json:"developmentMode,omitempty" tf:"development_mode,omitempty"`

	// +kubebuilder:validation:Optional
	EarlyHints *string `json:"earlyHints,omitempty" tf:"early_hints,omitempty"`

	// +kubebuilder:validation:Optional
	EmailObfuscation *string `json:"emailObfuscation,omitempty" tf:"email_obfuscation,omitempty"`

	// +kubebuilder:validation:Optional
	FilterLogsToCloudflare *string `json:"filterLogsToCloudflare,omitempty" tf:"filter_logs_to_cloudflare,omitempty"`

	// +kubebuilder:validation:Optional
	H2Prioritization *string `json:"h2Prioritization,omitempty" tf:"h2_prioritization,omitempty"`

	// +kubebuilder:validation:Optional
	HotlinkProtection *string `json:"hotlinkProtection,omitempty" tf:"hotlink_protection,omitempty"`

	// +kubebuilder:validation:Optional
	Http2 *string `json:"http2,omitempty" tf:"http2,omitempty"`

	// +kubebuilder:validation:Optional
	Http3 *string `json:"http3,omitempty" tf:"http3,omitempty"`

	// +kubebuilder:validation:Optional
	IPGeolocation *string `json:"ipGeolocation,omitempty" tf:"ip_geolocation,omitempty"`

	// +kubebuilder:validation:Optional
	IPv6 *string `json:"ipv6,omitempty" tf:"ipv6,omitempty"`

	// +kubebuilder:validation:Optional
	ImageResizing *string `json:"imageResizing,omitempty" tf:"image_resizing,omitempty"`

	// +kubebuilder:validation:Optional
	LogToCloudflare *string `json:"logToCloudflare,omitempty" tf:"log_to_cloudflare,omitempty"`

	// +kubebuilder:validation:Optional
	MaxUpload *float64 `json:"maxUpload,omitempty" tf:"max_upload,omitempty"`

	// +kubebuilder:validation:Optional
	MinTLSVersion *string `json:"minTlsVersion,omitempty" tf:"min_tls_version,omitempty"`

	// +kubebuilder:validation:Optional
	Minify []SettingsMinifyParameters `json:"minify,omitempty" tf:"minify,omitempty"`

	// +kubebuilder:validation:Optional
	Mirage *string `json:"mirage,omitempty" tf:"mirage,omitempty"`

	// +kubebuilder:validation:Optional
	MobileRedirect []SettingsMobileRedirectParameters `json:"mobileRedirect,omitempty" tf:"mobile_redirect,omitempty"`

	// +kubebuilder:validation:Optional
	OpportunisticEncryption *string `json:"opportunisticEncryption,omitempty" tf:"opportunistic_encryption,omitempty"`

	// +kubebuilder:validation:Optional
	OpportunisticOnion *string `json:"opportunisticOnion,omitempty" tf:"opportunistic_onion,omitempty"`

	// +kubebuilder:validation:Optional
	OrangeToOrange *string `json:"orangeToOrange,omitempty" tf:"orange_to_orange,omitempty"`

	// +kubebuilder:validation:Optional
	OriginErrorPagePassThru *string `json:"originErrorPagePassThru,omitempty" tf:"origin_error_page_pass_thru,omitempty"`

	// +kubebuilder:validation:Optional
	Polish *string `json:"polish,omitempty" tf:"polish,omitempty"`

	// +kubebuilder:validation:Optional
	PrefetchPreload *string `json:"prefetchPreload,omitempty" tf:"prefetch_preload,omitempty"`

	// +kubebuilder:validation:Optional
	PrivacyPass *string `json:"privacyPass,omitempty" tf:"privacy_pass,omitempty"`

	// +kubebuilder:validation:Optional
	ProxyReadTimeout *string `json:"proxyReadTimeout,omitempty" tf:"proxy_read_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	PseudoIPv4 *string `json:"pseudoIpv4,omitempty" tf:"pseudo_ipv4,omitempty"`

	// +kubebuilder:validation:Optional
	ResponseBuffering *string `json:"responseBuffering,omitempty" tf:"response_buffering,omitempty"`

	// +kubebuilder:validation:Optional
	RocketLoader *string `json:"rocketLoader,omitempty" tf:"rocket_loader,omitempty"`

	// +kubebuilder:validation:Optional
	SSL *string `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityHeader []SettingsSecurityHeaderParameters `json:"securityHeader,omitempty" tf:"security_header,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityLevel *string `json:"securityLevel,omitempty" tf:"security_level,omitempty"`

	// +kubebuilder:validation:Optional
	ServerSideExclude *string `json:"serverSideExclude,omitempty" tf:"server_side_exclude,omitempty"`

	// +kubebuilder:validation:Optional
	SortQueryStringForCache *string `json:"sortQueryStringForCache,omitempty" tf:"sort_query_string_for_cache,omitempty"`

	// +kubebuilder:validation:Optional
	TLS12Only *string `json:"tls12Only,omitempty" tf:"tls_1_2_only,omitempty"`

	// +kubebuilder:validation:Optional
	TLS13 *string `json:"tls13,omitempty" tf:"tls_1_3,omitempty"`

	// +kubebuilder:validation:Optional
	TLSClientAuth *string `json:"tlsClientAuth,omitempty" tf:"tls_client_auth,omitempty"`

	// +kubebuilder:validation:Optional
	TrueClientIPHeader *string `json:"trueClientIpHeader,omitempty" tf:"true_client_ip_header,omitempty"`

	// +kubebuilder:validation:Optional
	UniversalSSL *string `json:"universalSsl,omitempty" tf:"universal_ssl,omitempty"`

	// +kubebuilder:validation:Optional
	VisitorIP *string `json:"visitorIp,omitempty" tf:"visitor_ip,omitempty"`

	// +kubebuilder:validation:Optional
	Waf *string `json:"waf,omitempty" tf:"waf,omitempty"`

	// +kubebuilder:validation:Optional
	Webp *string `json:"webp,omitempty" tf:"webp,omitempty"`

	// +kubebuilder:validation:Optional
	Websockets *string `json:"websockets,omitempty" tf:"websockets,omitempty"`

	// +kubebuilder:validation:Optional
	ZeroRtt *string `json:"zeroRtt,omitempty" tf:"zero_rtt,omitempty"`
}

type SettingsSecurityHeaderObservation struct {
}

type SettingsSecurityHeaderParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IncludeSubdomains *bool `json:"includeSubdomains,omitempty" tf:"include_subdomains,omitempty"`

	// +kubebuilder:validation:Optional
	MaxAge *float64 `json:"maxAge,omitempty" tf:"max_age,omitempty"`

	// +kubebuilder:validation:Optional
	Nosniff *bool `json:"nosniff,omitempty" tf:"nosniff,omitempty"`

	// +kubebuilder:validation:Optional
	Preload *bool `json:"preload,omitempty" tf:"preload,omitempty"`
}

// SettingsOverrideSpec defines the desired state of SettingsOverride
type SettingsOverrideSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SettingsOverrideParameters `json:"forProvider"`
}

// SettingsOverrideStatus defines the observed state of SettingsOverride.
type SettingsOverrideStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SettingsOverrideObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// SettingsOverride is the Schema for the SettingsOverrides API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,cloudflarejet}
type SettingsOverride struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SettingsOverrideSpec   `json:"spec"`
	Status            SettingsOverrideStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SettingsOverrideList contains a list of SettingsOverrides
type SettingsOverrideList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SettingsOverride `json:"items"`
}

// Repository type metadata.
var (
	SettingsOverride_Kind             = "SettingsOverride"
	SettingsOverride_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: SettingsOverride_Kind}.String()
	SettingsOverride_KindAPIVersion   = SettingsOverride_Kind + "." + CRDGroupVersion.String()
	SettingsOverride_GroupVersionKind = CRDGroupVersion.WithKind(SettingsOverride_Kind)
)

func init() {
	SchemeBuilder.Register(&SettingsOverride{}, &SettingsOverrideList{})
}
